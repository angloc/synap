<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modern Flashcard App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .app-screen { display: none; }
        .app-screen.active { display: block; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        .tab-btn.active { 
            border-color: #0ea5e9; /* sky-500 */
            color: #0ea5e9;
        }
        .card-content { transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out; }
        .card-front.hidden { opacity: 0; transform: translateY(-20px); position: absolute; }
        .card-back { opacity: 0; transform: translateY(20px); position: absolute; }
        .card-back.visible { opacity: 1; transform: translateY(0); position: relative; }
        .explanation-content { transition: max-height 0.3s ease-in-out, opacity 0.3s ease-in-out; max-height: 0; opacity: 0; overflow: hidden; }
        .explanation-content.visible { max-height: 200px; opacity: 1; }
    </style>
</head>
<body class="bg-slate-100 dark:bg-slate-900 flex items-center justify-center min-h-screen p-4 transition-colors duration-300">

    <div id="app-container" class="w-full max-w-md">

        <!-- Storage Warning -->
        <div id="storage-warning" class="hidden bg-amber-100 dark:bg-amber-900/50 border-l-4 border-amber-500 text-amber-700 dark:text-amber-300 p-4 rounded-lg mb-4" role="alert">
            <p class="font-bold">Storage Warning</p>
            <p class="text-sm">Your browser is not saving data. Decks will not be remembered after you close this tab. This might be because you are in Private/Incognito mode.</p>
        </div>

        <!-- Main View Screen (Decks and Learning) -->
        <div id="main-view-screen" class="app-screen bg-white dark:bg-slate-800 rounded-2xl shadow-xl p-6 md:p-8">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-2xl font-bold text-slate-800 dark:text-white">Flashcards</h2>
                <button id="settings-btn" class="text-slate-400 hover:text-sky-500">
                     <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" /><path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /></svg>
                </button>
            </div>
            
            <!-- Tabs -->
            <div class="border-b border-slate-200 dark:border-slate-700 mb-6">
                <nav class="-mb-px flex space-x-6" aria-label="Tabs">
                    <button id="tab-decks" class="tab-btn whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm text-slate-500 hover:text-slate-700 dark:text-slate-400 dark:hover:text-slate-200">My Decks</button>
                    <button id="tab-learning" class="tab-btn whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm text-slate-500 hover:text-slate-700 dark:text-slate-400 dark:hover:text-slate-200">My Learning</button>
                </nav>
            </div>

            <!-- Tab Content: Decks -->
            <div id="tab-content-decks" class="tab-content">
                <div id="decks-container" class="space-y-3 mb-6 max-h-[50vh] overflow-y-auto pr-2">
                    <!-- Decks will be dynamically inserted here -->
                </div>
                <div class="border-t dark:border-slate-700 pt-6 space-y-3">
                    <form id="create-deck-form" class="flex space-x-2">
                        <input type="text" id="new-deck-name" placeholder="Enter new deck name..." class="w-full p-3 border border-slate-300 dark:border-slate-600 rounded-lg bg-white dark:bg-slate-700 focus:ring-2 focus:ring-sky-500 focus:outline-none" required>
                        <button type="submit" class="bg-sky-500 text-white font-bold p-3 rounded-lg hover:bg-sky-600 active:scale-95 transform transition-all duration-200">Create</button>
                    </form>
                    <div class="grid grid-cols-2 gap-3">
                         <button id="download-decks-btn" class="w-full bg-slate-200 dark:bg-slate-700 text-slate-700 dark:text-slate-200 font-bold py-3 px-4 rounded-lg hover:bg-slate-300 dark:hover:bg-slate-600 disabled:opacity-50 disabled:cursor-not-allowed" disabled>Download Selected</button>
                         <button id="upload-decks-btn" class="w-full bg-slate-200 dark:bg-slate-700 text-slate-700 dark:text-slate-200 font-bold py-3 px-4 rounded-lg hover:bg-slate-300 dark:hover:bg-slate-600">Upload Decks</button>
                         <input type="file" id="deck-upload-input" class="hidden" accept=".zip">
                    </div>
                </div>
            </div>

            <!-- Tab Content: Learning -->
            <div id="tab-content-learning" class="tab-content">
                <div id="learning-history-container" class="space-y-3 mb-6 max-h-[50vh] overflow-y-auto pr-2">
                    <!-- Learning history will be dynamically inserted here -->
                </div>
                <div class="border-t dark:border-slate-700 pt-6 grid grid-cols-2 gap-3">
                     <button id="download-history-btn" class="w-full bg-slate-200 dark:bg-slate-700 text-slate-700 dark:text-slate-200 font-bold py-3 px-4 rounded-lg hover:bg-slate-300 dark:hover:bg-slate-600">Download History</button>
                     <button id="upload-history-btn" class="w-full bg-slate-200 dark:bg-slate-700 text-slate-700 dark:text-slate-200 font-bold py-3 px-4 rounded-lg hover:bg-slate-300 dark:hover:bg-slate-600">Upload History</button>
                     <input type="file" id="history-upload-input" class="hidden" accept=".yaml,.yml">
                </div>
            </div>

        </div>

        <!-- Main Deck Screen -->
        <div id="main-deck-screen" class="app-screen">
             <div id="flashcard-deck" class="bg-white dark:bg-slate-800 rounded-2xl shadow-xl p-6 md:p-8 transition-all duration-300 relative">
                <div class="flex items-center mb-6">
                    <button id="back-to-main-view-btn-study" class="text-slate-400 hover:text-sky-500 mr-3">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M15 19l-7-7 7-7" /></svg>
                    </button>
                    <h2 id="deck-title-study" class="text-xl font-bold text-slate-800 dark:text-white truncate"></h2>
                </div>
                <!-- Progress -->
                <div class="mb-6">
                    <div class="flex justify-between items-center mb-2 text-slate-500 dark:text-slate-400">
                        <span class="text-sm font-medium">Progress</span>
                        <span id="progress-text" class="text-sm font-semibold">0 / 0</span>
                    </div>
                    <div class="bg-slate-200 dark:bg-slate-700 rounded-full h-2 w-full">
                        <div id="progress-bar" class="bg-sky-500 rounded-full h-2" style="width: 0%; transition: width 0.3s ease-in-out;"></div>
                    </div>
                </div>

                <!-- Card -->
                <div id="card-container" class="bg-slate-50 dark:bg-slate-900/50 rounded-xl min-h-[280px] flex flex-col justify-center p-6 text-center relative overflow-hidden">
                    <div id="card-front" class="card-content card-front w-full">
                        <p class="text-slate-500 dark:text-slate-400 text-sm mb-2">TERM</p>
                        <h2 id="card-question" class="text-2xl md:text-3xl font-bold text-slate-800 dark:text-white"></h2>
                    </div>
                    <div id="card-back" class="card-content card-back w-full">
                        <p class="text-sky-500 text-sm mb-2 font-semibold">DEFINITION</p>
                        <p id="card-answer" class="text-lg md:text-xl text-slate-700 dark:text-slate-200"></p>
                        <button id="show-explanation-btn" class="hidden mt-4 text-sm text-sky-500 font-semibold hover:underline">Show Explanation</button>
                        <div id="explanation-container" class="explanation-content text-left mt-4 pt-4 border-t border-slate-200 dark:border-slate-700">
                             <p id="card-explanation" class="text-sm text-slate-600 dark:text-slate-400 whitespace-pre-wrap"></p>
                        </div>
                    </div>
                     <div id="no-cards-message" class="hidden text-slate-500 dark:text-slate-400">
                        <p class="font-semibold text-lg">This deck is empty!</p>
                        <p class="text-sm mt-2">Go back and edit the deck to add flashcards.</p>
                    </div>
                </div>

                <!-- Action Buttons -->
                <div id="actions-container" class="mt-8">
                    <div id="show-answer-container">
                        <button id="show-answer-btn" class="w-full bg-sky-500 text-white font-bold py-3 px-4 rounded-lg hover:bg-sky-600 active:scale-95">Show Answer</button>
                    </div>
                    <div id="rating-container" class="hidden grid grid-cols-2 md:grid-cols-4 gap-3">
                        <button data-rating="again" class="rating-btn bg-red-100 dark:bg-red-900/50 text-red-600 dark:text-red-400 font-semibold py-3 px-2 rounded-lg hover:bg-red-200 dark:hover:bg-red-900">Again</button>
                        <button data-rating="hard" class="rating-btn bg-amber-100 dark:bg-amber-900/50 text-amber-600 dark:text-amber-400 font-semibold py-3 px-2 rounded-lg hover:bg-amber-200 dark:hover:bg-amber-900">Hard</button>
                        <button data-rating="good" class="rating-btn bg-green-100 dark:bg-green-900/50 text-green-600 dark:text-green-400 font-semibold py-3 px-2 rounded-lg hover:bg-green-200 dark:hover:bg-green-900">Good</button>
                        <button data-rating="easy" class="rating-btn bg-sky-100 dark:bg-sky-900/50 text-sky-600 dark:text-sky-400 font-semibold py-3 px-2 rounded-lg hover:bg-sky-200 dark:hover:bg-sky-900">Easy</button>
                    </div>
                </div>
            </div>

            <!-- Completion Screen -->
            <div id="completion-screen" class="hidden text-center bg-white dark:bg-slate-800 rounded-2xl shadow-xl p-8">
                <h2 class="text-2xl font-bold text-slate-800 dark:text-white">Session Complete!</h2>
                <button id="restart-btn" class="w-full mt-6 bg-sky-500 text-white font-bold py-3 px-4 rounded-lg hover:bg-sky-600 active:scale-95">Review Again</button>
            </div>
        </div>

        <!-- Manage Cards Screen -->
        <div id="manage-cards-screen" class="app-screen bg-white dark:bg-slate-800 rounded-2xl shadow-xl p-6 md:p-8">
            <div class="flex justify-between items-center mb-6">
                 <div class="flex items-center min-w-0">
                    <button id="back-to-main-view-btn-manage" class="text-slate-400 hover:text-sky-500 mr-3">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M15 19l-7-7 7-7" /></svg>
                    </button>
                    <h2 id="deck-title-manage" class="text-xl font-bold text-slate-800 dark:text-white truncate">Manage Cards</h2>
                 </div>
                 <div class="flex items-center space-x-2">
                    <button id="add-card-btn" class="text-sky-500 p-1 hover:text-sky-400">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-7 w-7" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-11a1 1 0 10-2 0v2H7a1 1 0 100 2h2v2a1 1 0 102 0v-2h2a1 1 0 100-2h-2V7z" clip-rule="evenodd" /></svg>
                    </button>
                    <button id="back-to-main-view-btn-manage-done" class="text-sky-500 dark:text-sky-400 font-semibold hover:underline flex-shrink-0">Done</button>
                 </div>
            </div>
            
            <div class="mb-6">
                 <h3 class="text-lg font-semibold text-slate-700 dark:text-slate-200 mb-3">Cards in Deck</h3>
                 <div id="cards-list" class="space-y-2 max-h-48 overflow-y-auto pr-2"></div>
            </div>

            <div id="ai-generation-container" class="border-t dark:border-slate-700 pt-6">
                 <h3 class="text-lg font-semibold text-slate-700 dark:text-slate-200 mb-3 flex items-center"><span class="mr-2">✨</span> AI Card Generation</h3>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-3">
                    <input type="text" id="ai-topic" placeholder="Enter topic..." class="md:col-span-2 w-full p-2 border border-slate-300 dark:border-slate-600 rounded-lg bg-white dark:bg-slate-700 focus:ring-2 focus:ring-sky-500 focus:outline-none">
                     <div>
                        <label for="ai-card-count" class="sr-only">Number of cards</label>
                        <input type="number" id="ai-card-count" value="10" min="1" max="20" class="w-full p-2 border border-slate-300 dark:border-slate-600 rounded-lg bg-white dark:bg-slate-700 focus:ring-2 focus:ring-sky-500 focus:outline-none">
                    </div>
                </div>
                <button id="generate-cards-btn" class="w-full mt-3 bg-gradient-to-r from-purple-500 to-sky-500 text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 active:scale-95 flex items-center justify-center">Generate Cards</button>
                <p id="ai-error" class="text-red-500 text-sm mt-2 text-center hidden"></p>
                <div id="ai-needs-key-message" class="hidden text-center mt-3 p-3 bg-slate-100 dark:bg-slate-700/50 rounded-lg">
                    <p class="text-sm text-slate-600 dark:text-slate-300">Please add your Gemini API key in <a href="#" id="go-to-settings-link" class="font-semibold text-sky-500 hover:underline">Settings</a> to use this feature.</p>
                </div>
            </div>

        </div>

        <!-- Settings Screen -->
        <div id="settings-screen" class="app-screen bg-white dark:bg-slate-800 rounded-2xl shadow-xl p-6 md:p-8">
            <div class="flex items-center mb-6">
                <button id="back-to-main-view-btn-settings" class="text-slate-400 hover:text-sky-500 mr-3">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M15 19l-7-7 7-7" /></svg>
                </button>
                <h2 class="text-xl font-bold text-slate-800 dark:text-white">Settings</h2>
            </div>
            <div class="space-y-4">
                <div>
                    <label for="gemini-api-key" class="block text-sm font-medium text-slate-700 dark:text-slate-200 mb-1">Gemini API Key</label>
                    <input type="password" id="gemini-api-key" placeholder="Enter your API key" class="w-full p-2 border border-slate-300 dark:border-slate-600 rounded-lg bg-white dark:bg-slate-700 focus:ring-2 focus:ring-sky-500 focus:outline-none">
                    <p class="text-xs text-slate-500 mt-1">To get an API key, <a href="https://aistudio.google.com/app/apikey" target="_blank" rel="noopener noreferrer" class="text-sky-500 hover:underline">click here</a>. Your key is stored securely in your browser's local storage.</p>
                </div>
                <div class="flex space-x-2">
                    <button id="save-api-key-btn" class="w-full bg-sky-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-sky-600">Save Key</button>
                    <button id="delete-api-key-btn" class="w-full bg-red-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-600">Delete Key</button>
                </div>
                 <p id="api-key-status" class="text-sm text-center text-green-600 dark:text-green-400"></p>
            </div>
        </div>

    </div>
    
    <!-- Add/Edit Card Modal -->
    <div id="card-editor-modal" class="hidden fixed inset-0 bg-slate-900 bg-opacity-60 flex items-center justify-center p-4 z-50">
        <form id="card-editor-form" class="bg-white dark:bg-slate-800 rounded-2xl shadow-xl p-6 md:p-8 w-full max-w-md">
            <h3 id="card-editor-title" class="text-lg font-semibold text-slate-700 dark:text-slate-200 mb-3">Add New Card</h3>
            <div class="space-y-3">
                <textarea id="edit-question" placeholder="Question / Term" rows="2" class="w-full p-2 border border-slate-300 dark:border-slate-600 rounded-lg bg-white dark:bg-slate-700 focus:ring-2 focus:ring-sky-500 focus:outline-none"></textarea>
                <textarea id="edit-answer" placeholder="Answer / Definition" rows="3" class="w-full p-2 border border-slate-300 dark:border-slate-600 rounded-lg bg-white dark:bg-slate-700 focus:ring-2 focus:ring-sky-500 focus:outline-none"></textarea>
                <textarea id="edit-explanation" placeholder="Optional: Fuller Explanation" rows="4" class="w-full p-2 border border-slate-300 dark:border-slate-600 rounded-lg bg-white dark:bg-slate-700 focus:ring-2 focus:ring-sky-500 focus:outline-none"></textarea>
            </div>
             <div class="flex items-center space-x-2 mt-4">
                <button type="submit" id="save-card-btn" class="w-full bg-sky-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-sky-600 active:scale-95">Add Card</button>
                <button type="button" id="cancel-edit-btn" class="w-full bg-slate-200 dark:bg-slate-600 text-slate-800 dark:text-slate-200 font-bold py-2 px-4 rounded-lg hover:bg-slate-300 dark:hover:bg-slate-500">Cancel</button>
             </div>
        </form>
    </div>


    <script>
    document.addEventListener('DOMContentLoaded', () => {
        console.log("DOM content loaded. App starting...");
        // --- Libraries ---
        const { JSZip, jsyaml } = window;
        if (!JSZip || !jsyaml) {
            console.error('Error: Required libraries (JSZip, js-yaml) not found.');
            document.body.innerHTML = `<div class="w-full max-w-md mx-auto my-8 p-6 bg-white dark:bg-slate-800 rounded-lg shadow-md text-center">
                <h1 class="text-2xl font-bold text-red-600 dark:text-red-400">Initialization Error</h1>
                <p class="mt-2 text-slate-700 dark:text-slate-200">Could not load required libraries (JSZip, js-yaml). Please check your internet connection and refresh the page.</p>
            </div>`;
            return;
        }
        console.log("Libraries (JSZip, js-yaml) found.");

        // --- Constants & State ---
        const DECKS_STORAGE_KEY = 'flashcard-app-decks-v2';
        const API_KEY_STORAGE_KEY = 'flashcard-app-gemini-api-key';
        const LEARNING_HISTORY_STORAGE_KEY = 'flashcard-app-learning-history';
        
        let decks = {};
        let learningHistory = [];
        let activeDeckId = null;
        let currentCardIndex = 0;
        let sessionScore = 0;
        let isFlipped = false;
        let editingCardIndex = null;
        let geminiApiKey = '';

        // --- DOM Elements ---
        const screens = { 
            mainView: document.getElementById('main-view-screen'), 
            mainDeck: document.getElementById('main-deck-screen'), 
            manageCards: document.getElementById('manage-cards-screen'),
            settings: document.getElementById('settings-screen')
        };
        // Main view tabs
        const tabDecks = document.getElementById('tab-decks');
        const tabLearning = document.getElementById('tab-learning');
        const tabContentDecks = document.getElementById('tab-content-decks');
        const tabContentLearning = document.getElementById('tab-content-learning');

        const decksContainer = document.getElementById('decks-container');
        const createDeckForm = document.getElementById('create-deck-form');
        const newDeckNameInput = document.getElementById('new-deck-name');
        const downloadBtn = document.getElementById('download-decks-btn');
        const uploadBtn = document.getElementById('upload-decks-btn');
        const uploadInput = document.getElementById('deck-upload-input');
        const settingsBtn = document.getElementById('settings-btn');

        // Learning history elements
        const learningHistoryContainer = document.getElementById('learning-history-container');
        const downloadHistoryBtn = document.getElementById('download-history-btn');
        const uploadHistoryBtn = document.getElementById('upload-history-btn');
        const historyUploadInput = document.getElementById('history-upload-input');
        
        const cardQuestion = document.getElementById('card-question'), cardAnswer = document.getElementById('card-answer'), cardFront = document.getElementById('card-front'), cardBack = document.getElementById('card-back'), noCardsMessage = document.getElementById('no-cards-message'), progressBar = document.getElementById('progress-bar'), progressText = document.getElementById('progress-text'), showAnswerBtn = document.getElementById('show-answer-btn'), showAnswerContainer = document.getElementById('show-answer-container'), ratingContainer = document.getElementById('rating-container'), ratingButtons = document.querySelectorAll('.rating-btn'), flashcardDeck = document.getElementById('flashcard-deck'), completionScreen = document.getElementById('completion-screen'), restartBtn = document.getElementById('restart-btn'), showExplanationBtn = document.getElementById('show-explanation-btn'), explanationContainer = document.getElementById('explanation-container'), cardExplanation = document.getElementById('card-explanation');

        const addCardBtn = document.getElementById('add-card-btn');
        const cardEditorModal = document.getElementById('card-editor-modal');
        const cardEditorForm = document.getElementById('card-editor-form'), cardEditorTitle = document.getElementById('card-editor-title'), editQuestion = document.getElementById('edit-question'), editAnswer = document.getElementById('edit-answer'), editExplanation = document.getElementById('edit-explanation'), saveCardBtn = document.getElementById('save-card-btn'), cancelEditBtn = document.getElementById('cancel-edit-btn'), cardsListContainer = document.getElementById('cards-list'), deckTitleStudy = document.getElementById('deck-title-study'), deckTitleManage = document.getElementById('deck-title-manage');

        const aiGenerationContainer = document.getElementById('ai-generation-container');
        const aiNeedsKeyMessage = document.getElementById('ai-needs-key-message');
        const goToSettingsLink = document.getElementById('go-to-settings-link');
        const generateCardsBtn = document.getElementById('generate-cards-btn'), aiTopicInput = document.getElementById('ai-topic'), aiCardCountInput = document.getElementById('ai-card-count'), aiError = document.getElementById('ai-error');
        
        const geminiApiKeyInput = document.getElementById('gemini-api-key');
        const saveApiKeyBtn = document.getElementById('save-api-key-btn');
        const deleteApiKeyBtn = document.getElementById('delete-api-key-btn');
        const apiKeyStatus = document.getElementById('api-key-status');

        // --- Navigation ---
        const showScreen = name => {
            console.log(`Switching to screen: ${name}`);
            Object.values(screens).forEach(s => s.classList.remove('active'));
            if (screens[name]) {
                screens[name].classList.add('active');
                console.log(`Successfully activated screen: ${name}`);
                if (name === 'manageCards') {
                    updateAiFeatureAvailability();
                } else if (name === 'mainView') {
                    renderDeckList();
                    renderLearningHistory();
                }
            } else {
                console.error(`Screen "${name}" not found.`);
            }
        };

        const showTab = (tabName) => {
            if (tabName === 'decks') {
                tabDecks.classList.add('active');
                tabLearning.classList.remove('active');
                tabContentDecks.classList.add('active');
                tabContentLearning.classList.remove('active');
            } else {
                tabDecks.classList.remove('active');
                tabLearning.classList.add('active');
                tabContentDecks.classList.remove('active');
                tabContentLearning.classList.add('active');
            }
        };

        tabDecks.addEventListener('click', () => showTab('decks'));
        tabLearning.addEventListener('click', () => showTab('learning'));

        document.getElementById('back-to-main-view-btn-study').addEventListener('click', () => showScreen('mainView'));
        document.getElementById('back-to-main-view-btn-manage').addEventListener('click', () => showScreen('mainView'));
        document.getElementById('back-to-main-view-btn-manage-done').addEventListener('click', () => showScreen('mainView'));
        document.getElementById('back-to-main-view-btn-settings').addEventListener('click', () => showScreen('mainView'));
        settingsBtn.addEventListener('click', () => showScreen('settings'));

        // --- Data Management ---
        function loadDecks() {
            console.log("Attempting to load decks from localStorage...");
            const storedDecks = localStorage.getItem(DECKS_STORAGE_KEY);
            try {
                if (storedDecks) decks = JSON.parse(storedDecks); else decks = {};
            } catch (e) {
                console.error("Failed to parse decks, starting fresh.", e);
                decks = {};
                localStorage.removeItem(DECKS_STORAGE_KEY);
            }
        }
        const saveDecks = () => {
             localStorage.setItem(DECKS_STORAGE_KEY, JSON.stringify(decks));
             console.log(`Saving decks to localStorage. Total decks: ${Object.keys(decks).length}`);
        };

        function loadLearningHistory() {
            const storedHistory = localStorage.getItem(LEARNING_HISTORY_STORAGE_KEY);
            try {
                if (storedHistory) learningHistory = JSON.parse(storedHistory); else learningHistory = [];
            } catch (e) {
                console.error("Failed to parse learning history, starting fresh.", e);
                learningHistory = [];
                localStorage.removeItem(LEARNING_HISTORY_STORAGE_KEY);
            }
        }

        const saveLearningHistory = () => {
            localStorage.setItem(LEARNING_HISTORY_STORAGE_KEY, JSON.stringify(learningHistory));
            console.log(`Saving learning history. Total records: ${learningHistory.length}`);
        };


        function loadApiKey() {
            geminiApiKey = localStorage.getItem(API_KEY_STORAGE_KEY) || '';
            geminiApiKeyInput.value = geminiApiKey;
        }

        function saveApiKey() {
            geminiApiKey = geminiApiKeyInput.value.trim();
            if (geminiApiKey) {
                localStorage.setItem(API_KEY_STORAGE_KEY, geminiApiKey);
                apiKeyStatus.textContent = 'API Key saved!';
            } else {
                localStorage.removeItem(API_KEY_STORAGE_KEY);
                apiKeyStatus.textContent = 'API Key cleared.';
            }
            setTimeout(() => apiKeyStatus.textContent = '', 2000);
        }

        function deleteApiKey() {
            localStorage.removeItem(API_KEY_STORAGE_KEY);
            geminiApiKey = '';
            geminiApiKeyInput.value = '';
            apiKeyStatus.textContent = 'API Key deleted.';
            setTimeout(() => apiKeyStatus.textContent = '', 2000);
        }

        saveApiKeyBtn.addEventListener('click', saveApiKey);
        deleteApiKeyBtn.addEventListener('click', deleteApiKey);


        // --- Deck List UI ---
        function renderDeckList() {
            console.log("Rendering deck list...");
            decksContainer.innerHTML = '';
            const deckIds = Object.keys(decks);
            if (deckIds.length === 0) {
                 decksContainer.innerHTML = `<p class="text-center text-slate-500 dark:text-slate-400">No decks yet, create or upload!</p>`;
                 return;
            }
            deckIds.forEach(id => {
                const deck = decks[id];
                const deckEl = document.createElement('div');
                deckEl.className = 'bg-slate-50 dark:bg-slate-700/50 p-3 rounded-lg flex items-center space-x-3';
                deckEl.innerHTML = `
                    <input type="checkbox" data-deck-id="${deck.id}" class="deck-checkbox h-5 w-5 rounded border-slate-300 text-sky-600 focus:ring-sky-500">
                    <div class="flex-grow min-w-0 cursor-pointer study-deck-area" data-deck-id="${deck.id}">
                        <p class="font-bold text-slate-800 dark:text-slate-100 truncate pointer-events-none">${deck.name}</p>
                        <p class="text-sm text-slate-500 dark:text-slate-400 pointer-events-none">${deck.cards.length} cards</p>
                    </div>
                    <div class="flex items-center space-x-2">
                        <button data-deck-id="${deck.id}" class="rename-deck-btn text-slate-500 hover:text-sky-500 p-1"><svg class="h-5 w-5 pointer-events-none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z" /></svg></button>
                        <button data-deck-id="${deck.id}" class="edit-deck-btn text-slate-500 hover:text-sky-500 p-1"><svg class="h-5 w-5 pointer-events-none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path d="M17.414 2.586a2 2 0 00-2.828 0L7 10.172V13h2.828l7.586-7.586a2 2 0 000-2.828z" /><path fill-rule="evenodd" d="M2 6a2 2 0 012-2h4a1 1 0 010 2H4v10h10v-4a1 1 0 112 0v4a2 2 0 01-2 2H4a2 2 0 01-2-2V6z" clip-rule="evenodd" /></svg></button>
                        <button data-deck-id="${deck.id}" class="delete-deck-btn text-slate-500 hover:text-red-500 p-1"><svg class="h-5 w-5 pointer-events-none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" /></svg></button>
                    </div>
                `;
                decksContainer.appendChild(deckEl);
            });
        }

        function handleDeckListActions(e) {
            const target = e.target;
            
            if (target.classList.contains('deck-checkbox')) {
                const checked = decksContainer.querySelectorAll('.deck-checkbox:checked').length > 0;
                downloadBtn.disabled = !checked;
                return;
            }

            const deckItem = target.closest('[data-deck-id]');
            if (!deckItem) return;
            const deckId = deckItem.dataset.deckId;

            if (target.closest('.study-deck-area')) {
                activeDeckId = deckId;
                deckTitleStudy.textContent = decks[activeDeckId].name;
                restartSession();
                showScreen('mainDeck');
            } 
            else if (target.closest('.edit-deck-btn')) {
                activeDeckId = deckId;
                deckTitleManage.textContent = decks[activeDeckId].name;
                renderManageList();
                showScreen('manageCards');
            } else if (target.closest('.rename-deck-btn')) {
                const oldName = decks[deckId].name;
                const newName = prompt('Enter new deck name:', oldName);
                if (newName && newName.trim() && newName.trim() !== oldName) {
                    decks[deckId].name = newName.trim();
                    saveDecks();
                    renderDeckList();
                }
            } else if (target.closest('.delete-deck-btn')) {
                delete decks[deckId];
                saveDecks();
                renderDeckList();
            }
        }

        createDeckForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const name = newDeckNameInput.value.trim();
            if (name) {
                const id = `deck-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
                decks[id] = { id, name, cards: [] };
                saveDecks();
                renderDeckList();
                newDeckNameInput.value = '';
            }
        });

        // --- Import/Export ---
        downloadBtn.addEventListener('click', async () => {
            const selectedIds = [...decksContainer.querySelectorAll('.deck-checkbox:checked')].map(cb => cb.dataset.deckId);
            if (selectedIds.length === 0) return;

            const zip = new JSZip();
            selectedIds.forEach(id => {
                const deck = decks[id];
                const yamlString = jsyaml.dump(deck);
                const filename = `${deck.name.replace(/[^a-z0-9]/gi, '_')}.yaml`;
                zip.file(filename, yamlString);
            });

            const content = await zip.generateAsync({ type: 'blob' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(content);
            link.download = 'flashcard_decks.zip';
            link.click();
            URL.revokeObjectURL(link.href);
        });

        uploadBtn.addEventListener('click', () => uploadInput.click());
        uploadInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const zip = await JSZip.loadAsync(file);
            const existingNames = Object.values(decks).map(d => d.name);

            for (const filename in zip.files) {
                if (filename.endsWith('.yaml') || filename.endsWith('.yml')) {
                    const fileContent = await zip.files[filename].async('string');
                    try {
                        let importedDeck = jsyaml.load(fileContent);
                        if (importedDeck && importedDeck.name && Array.isArray(importedDeck.cards)) {
                             let newName = importedDeck.name;
                             let counter = 1;
                             while(existingNames.includes(newName)) {
                                 newName = `${importedDeck.name} (${counter++})`;
                             }
                             importedDeck.name = newName;
                             importedDeck.id = `deck-${Date.now()}-${Math.random()}`;
                             decks[importedDeck.id] = importedDeck;
                             existingNames.push(newName);
                        }
                    } catch (err) { console.error(`Failed to parse ${filename}:`, err); }
                }
            }
            saveDecks();
            renderDeckList();
            e.target.value = '';
        });
        
        // --- GEMINI API ---
        async function callGemini(payload) {
            const apiKey = geminiApiKey || '';
            if (!apiKey) {
                throw new Error("Gemini API key not found.");
            }
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (response.status === 400) {
                     throw new Error("Invalid API Key. Please check your key in Settings.");
                } else if (response.status === 429) {
                    throw new Error("API quota exceeded. Please check your usage in the Google AI Studio.");
                } else if (!response.ok) {
                    throw new Error(`API Error: ${response.status}`);
                }

                const result = await response.json();
                const text = result.candidates?.[0]?.content?.parts?.[0]?.text;
                if (!text) throw new Error("No content received from API.");
                return text;
            } catch (error) {
                console.error("Error calling Gemini API:", error);
                throw error; // Re-throw the specific or generic error
            }
        }
        
        // --- Main Deck Functions ---
        function updateProgress() {
            const cards = decks[activeDeckId]?.cards || [];
            if (cards.length === 0) {
                progressBar.style.width = '0%';
                progressText.textContent = `0 / 0`;
                return;
            }
            const progress = (currentCardIndex / cards.length) * 100;
            progressBar.style.width = `${progress}%`;
            progressText.textContent = `${currentCardIndex} / ${cards.length}`;
        }

        function displayCard(index) {
            const cards = decks[activeDeckId]?.cards || [];
            if (cards.length === 0) {
                noCardsMessage.classList.remove('hidden');
                cardFront.classList.add('hidden');
                cardBack.classList.remove('visible');
                showAnswerContainer.classList.add('hidden');
                updateProgress();
                return;
            }
            noCardsMessage.classList.add('hidden');
            if (index >= cards.length) {
                showCompletionScreen();
                return;
            }
            showAnswerContainer.classList.remove('hidden');
            const card = cards[index];
            cardQuestion.textContent = card.question;
            cardAnswer.textContent = card.answer;
            cardExplanation.textContent = card.explanation || '';
            showExplanationBtn.classList.toggle('hidden', !card.explanation);
            updateProgress();
            resetCardState();
        }
        
        function flipCard() {
            if (!activeDeckId || decks[activeDeckId].cards.length === 0) return;
            isFlipped = true;
            cardFront.classList.add('hidden');
            cardBack.classList.add('visible');
            showAnswerContainer.classList.add('hidden');
            ratingContainer.classList.remove('hidden');
        }

        function resetCardState() {
            isFlipped = false;
            cardFront.classList.remove('hidden');
            cardBack.classList.remove('visible');
            showAnswerContainer.classList.remove('hidden');
            ratingContainer.classList.add('hidden');
            explanationContainer.classList.remove('visible');
            showExplanationBtn.textContent = 'Show Explanation';
        }
        
        function handleRating(e) {
            const rating = e.target.dataset.rating;
            switch(rating) {
                case 'hard': sessionScore += 1; break;
                case 'good': sessionScore += 3; break;
                case 'easy': sessionScore += 5; break;
                default: sessionScore += 0;
            }
            currentCardIndex++; 
            displayCard(currentCardIndex); 
        }

        function showCompletionScreen() { 
            flashcardDeck.classList.add('hidden'); 
            completionScreen.classList.remove('hidden');
            recordSession();
        }

        function recordSession() {
            if (!activeDeckId) return;
            const record = {
                id: `session-${Date.now()}`,
                deckId: activeDeckId,
                deckName: decks[activeDeckId].name,
                timestamp: new Date().toISOString(),
                score: sessionScore
            };
            learningHistory.unshift(record);
            saveLearningHistory();
        }

        function restartSession() {
            currentCardIndex = 0;
            sessionScore = 0;
            completionScreen.classList.add('hidden');
            flashcardDeck.classList.remove('hidden');
            displayCard(currentCardIndex);
        }
        showExplanationBtn.addEventListener('click', () => {
            explanationContainer.classList.toggle('visible');
            showExplanationBtn.textContent = explanationContainer.classList.contains('visible') ? 'Hide Explanation' : 'Show Explanation';
        });

        // --- Manage Cards UI & Modal ---
        function openModal() { cardEditorModal.classList.remove('hidden'); }
        function closeModal() { cardEditorModal.classList.add('hidden'); resetCardEditor(); }

        function renderManageList() {
            cardsListContainer.innerHTML = '';
            const cards = decks[activeDeckId]?.cards || [];
            if (cards.length === 0) {
                cardsListContainer.innerHTML = `<p class="text-sm text-slate-400">This deck is empty. Add or generate cards!</p>`;
                return;
            }
            cards.forEach((card, index) => {
                const cardEl = document.createElement('div');
                cardEl.className = 'bg-slate-50 dark:bg-slate-700/50 p-3 rounded-lg flex justify-between items-start cursor-pointer hover:bg-slate-100 dark:hover:bg-slate-700';
                cardEl.dataset.index = index;
                cardEl.innerHTML = `<div class="pr-4 overflow-hidden"><p class="font-semibold text-sm text-slate-800 dark:text-slate-100 truncate">${card.question}</p><p class="text-xs text-slate-500 dark:text-slate-400 mt-1 truncate">${card.answer}</p></div><button data-index="${index}" class="delete-card-btn flex-shrink-0 text-red-500 hover:text-red-700 p-1"><svg class="h-5 w-5 pointer-events-none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" /></svg></button>`;
                cardsListContainer.appendChild(cardEl);
            });
        }

        function handleCardListClick(e) {
            const deleteBtn = e.target.closest('.delete-card-btn');
            if (deleteBtn) {
                const index = parseInt(deleteBtn.dataset.index, 10);
                decks[activeDeckId].cards.splice(index, 1);
                saveDecks();
                renderManageList();
            } else {
                const cardEl = e.target.closest('[data-index]');
                if (cardEl) {
                    populateCardEditor(parseInt(cardEl.dataset.index, 10));
                    openModal();
                }
            }
        }

        function populateCardEditor(index) {
            const card = decks[activeDeckId].cards[index];
            editingCardIndex = index;
            cardEditorTitle.textContent = 'Edit Card';
            editQuestion.value = card.question;
            editAnswer.value = card.answer;
            editExplanation.value = card.explanation || '';
            saveCardBtn.textContent = 'Update Card';
        }

        function resetCardEditor() {
            editingCardIndex = null;
            cardEditorForm.reset();
            cardEditorTitle.textContent = 'Add New Card';
            saveCardBtn.textContent = 'Add Card';
        }
        
        cardEditorForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const question = editQuestion.value.trim();
            const answer = editAnswer.value.trim();
            const explanation = editExplanation.value.trim();
            if (!question || !answer) return;

            const cardData = { question, answer, explanation };
            if (editingCardIndex !== null) {
                decks[activeDeckId].cards[editingCardIndex] = cardData;
            } else {
                decks[activeDeckId].cards.unshift(cardData);
            }
            saveDecks();
            renderManageList();
            closeModal();
        });
        
        addCardBtn.addEventListener('click', () => {
            resetCardEditor();
            openModal();
        });
        cancelEditBtn.addEventListener('click', closeModal);
        cardEditorModal.addEventListener('click', (e) => {
            if (e.target === cardEditorModal) closeModal();
        });


        // --- AI Feature Handlers ---
        function updateAiFeatureAvailability() {
            const hasApiKey = !!geminiApiKey;
            aiGenerationContainer.querySelectorAll('input, button').forEach(el => el.disabled = !hasApiKey);
            aiNeedsKeyMessage.classList.toggle('hidden', hasApiKey);
        }
        
        async function handleGenerateCards(e) {
            e.preventDefault();
            const topic = aiTopicInput.value.trim();
            const count = parseInt(aiCardCountInput.value, 10) || 10;
            if (!topic || !activeDeckId || count < 1) return;

            generateCardsBtn.disabled = true;
            generateCardsBtn.innerHTML = `<svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg> Generating...`;
            aiError.classList.add('hidden');

            const schema = { type: "ARRAY", items: { type: "OBJECT", properties: { "question": { "type": "STRING" }, "answer": { "type": "STRING" }, "explanation": { "type": "STRING" }}, required: ["question", "answer"] } };
            const prompt = `Generate ${count} flashcards for the topic "${topic}". For each card, provide a "question", a concise "answer", and an "explanation". The explanation should be a fuller, more detailed description of the answer, but leave it as an empty string if the term is simple vocabulary where no explanation is needed.`;
            const payload = { contents: [{ parts: [{ text: prompt }] }], generationConfig: { responseMimeType: "application/json", responseSchema: schema } };

            try {
                const resultText = await callGemini(payload);
                const newCards = JSON.parse(resultText);
                decks[activeDeckId].cards.unshift(...newCards);
                saveDecks();
                renderManageList();
                aiTopicInput.value = '';
            } catch (error) {
                aiError.textContent = `Could not generate cards. ${error.message}`;
                aiError.classList.remove('hidden');
            } finally {
                generateCardsBtn.disabled = false;
                generateCardsBtn.textContent = 'Generate Cards';
            }
        }

        // --- Learning History ---
        function renderLearningHistory() {
            learningHistoryContainer.innerHTML = '';
            if (learningHistory.length === 0) {
                learningHistoryContainer.innerHTML = `<p class="text-center text-slate-500 dark:text-slate-400">No learning history yet. Complete a study session to see your progress!</p>`;
                return;
            }
            const table = document.createElement('table');
            table.className = 'w-full text-sm text-left';
            table.innerHTML = `
                <thead class="text-xs text-slate-700 uppercase bg-slate-50 dark:bg-slate-700 dark:text-slate-400">
                    <tr>
                        <th scope="col" class="px-4 py-3">Deck</th>
                        <th scope="col" class="px-4 py-3">Date</th>
                        <th scope="col" class="px-4 py-3">Score</th>
                        <th scope="col" class="px-4 py-3"><span class="sr-only">Actions</span></th>
                    </tr>
                </thead>
            `;
            const tbody = document.createElement('tbody');
            learningHistory.forEach(record => {
                const tr = document.createElement('tr');
                tr.className = 'border-b dark:border-slate-700';
                const date = new Date(record.timestamp).toLocaleDateString();
                tr.innerHTML = `
                    <td class="px-4 py-3 font-medium text-slate-900 dark:text-white">${record.deckName}</td>
                    <td class="px-4 py-3 text-slate-500 dark:text-slate-400">${date}</td>
                    <td class="px-4 py-3 font-semibold">${record.score}</td>
                    <td class="px-4 py-3 text-right">
                        <button class="font-medium text-sky-600 dark:text-sky-500 hover:underline study-history-btn" data-deck-id="${record.deckId}">Study</button>
                        <button class="font-medium text-red-600 dark:text-red-500 hover:underline ml-3 delete-history-btn" data-record-id="${record.id}">Delete</button>
                    </td>
                `;
                tbody.appendChild(tr);
            });
            table.appendChild(tbody);
            learningHistoryContainer.appendChild(table);
        }

        learningHistoryContainer.addEventListener('click', (e) => {
            if (e.target.classList.contains('study-history-btn')) {
                const deckId = e.target.dataset.deckId;
                if (decks[deckId]) {
                    activeDeckId = deckId;
                    deckTitleStudy.textContent = decks[activeDeckId].name;
                    restartSession();
                    showScreen('mainDeck');
                } else {
                    alert('This deck no longer exists.');
                }
            } else if (e.target.classList.contains('delete-history-btn')) {
                const recordId = e.target.dataset.recordId;
                learningHistory = learningHistory.filter(r => r.id !== recordId);
                saveLearningHistory();
                renderLearningHistory();
            }
        });

        downloadHistoryBtn.addEventListener('click', () => {
            if(learningHistory.length === 0) return;
            const yamlString = jsyaml.dump(learningHistory);
            const blob = new Blob([yamlString], { type: 'text/yaml' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'learning_history.yaml';
            link.click();
            URL.revokeObjectURL(link.href);
        });

        uploadHistoryBtn.addEventListener('click', () => historyUploadInput.click());
        historyUploadInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const importedHistory = jsyaml.load(event.target.result);
                    if (Array.isArray(importedHistory)) {
                        const existingIds = new Set(learningHistory.map(r => r.id));
                        const newRecords = importedHistory.filter(r => !existingIds.has(r.id));
                        learningHistory.unshift(...newRecords);
                        learningHistory.sort((a,b) => new Date(b.timestamp) - new Date(a.timestamp));
                        saveLearningHistory();
                        renderLearningHistory();
                    }
                } catch (err) {
                    console.error("Failed to parse history file", err);
                    alert("Could not read the uploaded history file.");
                }
            };
            reader.readAsText(file);
            e.target.value = '';
        });


        // --- INITIALIZATION ---
        function isLocalStorageAvailable() {
            let storage;
            try {
                storage = window.localStorage;
                const x = '__storage_test__';
                storage.setItem(x, x);
                storage.removeItem(x);
                return true;
            } catch (e) {
                return false;
            }
        }

        function init() {
            console.log("Initializing app...");

            if (!isLocalStorageAvailable()) {
                console.warn("Local storage is not available.");
                document.getElementById('storage-warning').classList.remove('hidden');
            }

            loadDecks();
            loadApiKey();
            loadLearningHistory();
            renderDeckList();
            renderLearningHistory();

            console.log("Attaching event listeners...");
            decksContainer.addEventListener('click', handleDeckListActions);
            showAnswerBtn.addEventListener('click', flipCard);
            ratingButtons.forEach(button => button.addEventListener('click', handleRating));
            restartBtn.addEventListener('click', restartSession);
            cardsListContainer.addEventListener('click', handleCardListClick);
            generateCardsBtn.addEventListener('click', handleGenerateCards);
            goToSettingsLink.addEventListener('click', (e) => {
                e.preventDefault();
                showScreen('settings');
            });
            
            console.log("Initialization complete. Showing initial screen.");
            showTab('decks');
            showScreen('mainView');
        }

        init();
    });
    </script>
</body>
</html>

