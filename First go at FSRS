<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Synap</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <script type="module">
        import * as tsFsrs from 'https://cdn.jsdelivr.net/npm/ts-fsrs@latest/+esm';
        window.tsfsrs = tsFsrs
    </script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            -webkit-user-select: none; /* Safari */
            -ms-user-select: none; /* IE 10+ */
            user-select: none; /* Standard syntax */
        }
        /* Allow text selection on inputs and textareas */
        input, textarea {
            -webkit-user-select: text;
            -ms-user-select: text;
            user-select: text;
        }
        .app-screen { display: none; }
        .app-screen.active { display: block; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        .tab-btn.active { 
            border-color: #0ea5e9; /* sky-500 */
            color: #0ea5e9;
        }
        .card-content { transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out; }
        .card-front.hidden { opacity: 0; transform: translateY(-20px); position: absolute; }
        .card-back { opacity: 0; transform: translateY(20px); position: absolute; }
        .card-back.visible { opacity: 1; transform: translateY(0); position: relative; }
        .explanation-content { transition: max-height 0.3s ease-in-out, opacity 0.3s ease-in-out; max-height: 0; opacity: 0; overflow: hidden; }
        .explanation-content.visible { max-height: 200px; opacity: 1; }
        .schedule-color-red { color: #ef4444; } /* red-500 */
        .schedule-color-green { color: #22c55e; } /* green-500 */
        .schedule-color-blue { color: #3b82f6; } /* blue-500 */

    </style>
</head>
<body class="bg-slate-100 dark:bg-slate-900 flex items-center justify-center min-h-screen p-4 transition-colors duration-300">

    <div id="app-container" class="w-full max-w-md">

        <!-- Storage Warning -->
        <div id="storage-warning" class="hidden bg-amber-100 dark:bg-amber-900/50 border-l-4 border-amber-500 text-amber-700 dark:text-amber-300 p-4 rounded-lg mb-4" role="alert">
            <p class="font-bold">Storage Warning</p>
            <p class="text-sm">Your browser is not saving data. Decks will not be remembered after you close this tab. This might be because you are in Private/Incognito mode.</p>
        </div>

        <!-- Main View Screen (Decks and Learning) -->
        <div id="main-view-screen" class="app-screen bg-white dark:bg-slate-800 rounded-2xl shadow-xl p-6 md:p-8">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-2xl font-bold text-slate-800 dark:text-white">Synap</h2>
                <button id="settings-btn" class="text-slate-400 hover:text-sky-500">
                     <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" /><path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /></svg>
                </button>
            </div>
            
            <!-- Tabs -->
            <div class="border-b border-slate-200 dark:border-slate-700 mb-6">
                <nav class="-mb-px flex space-x-6" aria-label="Tabs">
                    <button id="tab-decks" class="tab-btn whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm text-slate-500 hover:text-slate-700 dark:text-slate-400 dark:hover:text-slate-200">My Decks</button>
                    <button id="tab-schedule" class="tab-btn whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm text-slate-500 hover:text-slate-700 dark:text-slate-400 dark:hover:text-slate-200">My Schedule</button>
                    <button id="tab-learning" class="tab-btn whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm text-slate-500 hover:text-slate-700 dark:text-slate-400 dark:hover:text-slate-200">My Learning</button>
                </nav>
            </div>

            <!-- Tab Content: Decks -->
            <div id="tab-content-decks" class="tab-content">
                <div id="decks-container" class="space-y-3 mb-6 max-h-[50vh] overflow-y-auto pr-2">
                    <!-- Decks will be dynamically inserted here -->
                </div>
                <div class="border-t dark:border-slate-700 pt-6 space-y-3">
                    <form id="create-deck-form" class="flex space-x-2">
                        <input type="text" id="new-deck-name" placeholder="Enter new deck name..." class="w-full p-3 border border-slate-300 dark:border-slate-600 rounded-lg bg-white dark:bg-slate-700 focus:ring-2 focus:ring-sky-500 focus:outline-none" required>
                        <button type="submit" class="bg-sky-500 text-white font-bold p-3 rounded-lg hover:bg-sky-600 active:scale-95 transform transition-all duration-200">Create</button>
                    </form>
                    <div class="grid grid-cols-2 gap-3">
                         <button id="download-decks-btn" class="w-full bg-slate-200 dark:bg-slate-700 text-slate-700 dark:text-slate-200 font-bold py-3 px-4 rounded-lg hover:bg-slate-300 dark:hover:bg-slate-600 disabled:opacity-50 disabled:cursor-not-allowed" disabled>Download Selected</button>
                         <button id="upload-decks-btn" class="w-full bg-slate-200 dark:bg-slate-700 text-slate-700 dark:text-slate-200 font-bold py-3 px-4 rounded-lg hover:bg-slate-300 dark:hover:bg-slate-600">Upload Decks</button>
                         <input type="file" id="deck-upload-input" class="hidden" accept=".zip">
                    </div>
                </div>
            </div>

            <!-- Tab Content: Schedule -->
            <div id="tab-content-schedule" class="tab-content">
                <div id="schedule-container" class="space-y-3 mb-6 max-h-[60vh] overflow-y-auto pr-2">
                    <!-- Schedule will be dynamically inserted here -->
                </div>
            </div>

            <!-- Tab Content: Learning -->
            <div id="tab-content-learning" class="tab-content">
                <div class="mb-4">
                    <input type="text" id="learning-search-input" placeholder="Search deck or card..." class="w-full p-2 border border-slate-300 dark:border-slate-600 rounded-lg bg-white dark:bg-slate-700 focus:ring-2 focus:ring-sky-500 focus:outline-none">
                </div>
                <div id="learning-history-container" class="space-y-3 mb-6 max-h-[50vh] overflow-y-auto pr-2">
                    <!-- Learning history will be dynamically inserted here -->
                </div>
                <div class="border-t dark:border-slate-700 pt-6 grid grid-cols-2 gap-3">
                     <button id="download-history-btn" class="w-full bg-slate-200 dark:bg-slate-700 text-slate-700 dark:text-slate-200 font-bold py-3 px-4 rounded-lg hover:bg-slate-300 dark:hover:bg-slate-600">Download History</button>
                     <button id="upload-history-btn" class="w-full bg-slate-200 dark:bg-slate-700 text-slate-700 dark:text-slate-200 font-bold py-3 px-4 rounded-lg hover:bg-slate-300 dark:hover:bg-slate-600">Upload History</button>
                     <input type="file" id="history-upload-input" class="hidden" accept=".yaml,.yml">
                </div>
            </div>

        </div>

        <!-- Main Deck Screen -->
        <div id="main-deck-screen" class="app-screen">
             <div id="flashcard-deck" class="bg-white dark:bg-slate-800 rounded-2xl shadow-xl p-6 md:p-8 transition-all duration-300 relative">
                <div class="flex items-center mb-6">
                    <button id="back-to-main-view-btn-study" class="text-slate-400 hover:text-sky-500 mr-3">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M15 19l-7-7 7-7" /></svg>
                    </button>
                    <h2 id="deck-title-study" class="text-xl font-bold text-slate-800 dark:text-white truncate"></h2>
                </div>
                <!-- Progress -->
                <div class="mb-6">
                    <div class="flex justify-between items-center mb-2 text-slate-500 dark:text-slate-400">
                        <span class="text-sm font-medium">Progress</span>
                        <span id="progress-text" class="text-sm font-semibold">0 / 0</span>
                    </div>
                    <div class="bg-slate-200 dark:bg-slate-700 rounded-full h-2 w-full">
                        <div id="progress-bar" class="bg-sky-500 rounded-full h-2" style="width: 0%; transition: width 0.3s ease-in-out;"></div>
                    </div>
                </div>

                <!-- Card -->
                <div id="card-container" class="bg-slate-50 dark:bg-slate-900/50 rounded-xl min-h-[280px] flex flex-col justify-center p-6 text-center relative overflow-hidden">
                    <div id="card-front" class="card-content card-front w-full">
                        <p class="text-slate-500 dark:text-slate-400 text-sm mb-2">TERM</p>
                        <h2 id="card-question" class="text-2xl md:text-3xl font-bold text-slate-800 dark:text-white"></h2>
                    </div>
                    <div id="card-back" class="card-content card-back w-full">
                        <p class="text-sky-500 text-sm mb-2 font-semibold">DEFINITION</p>
                        <p id="card-answer" class="text-lg md:text-xl text-slate-700 dark:text-slate-200"></p>
                        <button id="show-explanation-btn" class="hidden mt-4 text-sm text-sky-500 font-semibold hover:underline">Show Explanation</button>
                        <div id="explanation-container" class="explanation-content text-left mt-4 pt-4 border-t border-slate-200 dark:border-slate-700">
                             <p id="card-explanation" class="text-sm text-slate-600 dark:text-slate-400 whitespace-pre-wrap"></p>
                        </div>
                    </div>
                     <div id="no-cards-message" class="hidden text-slate-500 dark:text-slate-400">
                        <p class="font-semibold text-lg">This deck is empty!</p>
                        <p class="text-sm mt-2">Go back and edit the deck to add flashcards.</p>
                    </div>
                </div>

                <!-- Action Buttons -->
                <div id="actions-container" class="mt-8">
                    <div id="show-answer-container">
                        <button id="show-answer-btn" class="w-full bg-sky-500 text-white font-bold py-3 px-4 rounded-lg hover:bg-sky-600 active:scale-95">Show Answer</button>
                    </div>
                    <div id="rating-container" class="hidden grid grid-cols-2 md:grid-cols-4 gap-3">
                        <button data-rating="again" class="rating-btn bg-red-100 dark:bg-red-900/50 text-red-600 dark:text-red-400 font-semibold py-3 px-2 rounded-lg hover:bg-red-200 dark:hover:bg-red-900">Again</button>
                        <button data-rating="hard" class="rating-btn bg-amber-100 dark:bg-amber-900/50 text-amber-600 dark:text-amber-400 font-semibold py-3 px-2 rounded-lg hover:bg-amber-200 dark:hover:bg-amber-900">Hard</button>
                        <button data-rating="good" class="rating-btn bg-green-100 dark:bg-green-900/50 text-green-600 dark:text-green-400 font-semibold py-3 px-2 rounded-lg hover:bg-green-200 dark:hover:bg-green-900">Good</button>
                        <button data-rating="easy" class="rating-btn bg-sky-100 dark:bg-sky-900/50 text-sky-600 dark:text-sky-400 font-semibold py-3 px-2 rounded-lg hover:bg-sky-200 dark:hover:bg-sky-900">Easy</button>
                    </div>
                </div>
            </div>

            <!-- Completion Screen -->
            <div id="completion-screen" class="hidden text-center bg-white dark:bg-slate-800 rounded-2xl shadow-xl p-8">
                <h2 class="text-2xl font-bold text-slate-800 dark:text-white">Session Complete!</h2>
                <div class="mt-6 grid grid-cols-1 sm:grid-cols-2 gap-3">
                     <button id="back-to-main-from-complete-btn" class="w-full bg-sky-500 text-white font-bold py-3 px-4 rounded-lg hover:bg-sky-600 active:scale-95">Back to Decks</button>
                     <button id="restart-btn" class="w-full bg-slate-200 dark:bg-slate-700 text-slate-700 dark:text-slate-200 font-bold py-3 px-4 rounded-lg hover:bg-slate-300 dark:hover:bg-slate-600 active:scale-95">Review Again</button>
                </div>
            </div>
        </div>

        <!-- Manage Cards Screen -->
        <div id="manage-cards-screen" class="app-screen bg-white dark:bg-slate-800 rounded-2xl shadow-xl p-6 md:p-8">
            <div class="flex justify-between items-center mb-6">
                 <div class="flex items-center min-w-0">
                    <button id="back-to-main-view-btn-manage" class="text-slate-400 hover:text-sky-500 mr-3">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M15 19l-7-7 7-7" /></svg>
                    </button>
                    <h2 id="deck-title-manage" class="text-xl font-bold text-slate-800 dark:text-white truncate">Manage Cards</h2>
                 </div>
                 <div class="flex items-center space-x-2">
                    <button id="add-card-btn" class="text-sky-500 p-1 hover:text-sky-400">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-7 w-7" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-11a1 1 0 10-2 0v2H7a1 1 0 100 2h2v2a1 1 0 102 0v-2h2a1 1 0 100-2h-2V7z" clip-rule="evenodd" /></svg>
                    </button>
                    <button id="back-to-main-view-btn-manage-done" class="text-sky-500 dark:text-sky-400 font-semibold hover:underline flex-shrink-0">Done</button>
                 </div>
            </div>
            
            <div class="mb-6">
                 <h3 class="text-lg font-semibold text-slate-700 dark:text-slate-200 mb-3">Cards in Deck</h3>
                 <div id="cards-list" class="space-y-2 max-h-48 overflow-y-auto pr-2"></div>
            </div>

            <div id="ai-generation-container" class="border-t dark:border-slate-700 pt-6">
                 <h3 class="text-lg font-semibold text-slate-700 dark:text-slate-200 mb-3 flex items-center"><span class="mr-2">âœ¨</span> AI Card Generation</h3>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-3">
                    <input type="text" id="ai-topic" placeholder="Enter topic..." class="md:col-span-2 w-full p-2 border border-slate-300 dark:border-slate-600 rounded-lg bg-white dark:bg-slate-700 focus:ring-2 focus:ring-sky-500 focus:outline-none">
                     <div>
                        <label for="ai-card-count" class="sr-only">Number of cards</label>
                        <input type="number" id="ai-card-count" value="10" min="1" max="20" class="w-full p-2 border border-slate-300 dark:border-slate-600 rounded-lg bg-white dark:bg-slate-700 focus:ring-2 focus:ring-sky-500 focus:outline-none">
                    </div>
                </div>
                <button id="generate-cards-btn" class="w-full mt-3 bg-gradient-to-r from-purple-500 to-sky-500 text-white font-bold py-2 px-4 rounded-lg hover:opacity-90 active:scale-95 flex items-center justify-center">Generate Cards</button>
                <p id="ai-error" class="text-red-500 text-sm mt-2 text-center hidden"></p>
                <div id="ai-needs-key-message" class="hidden text-center mt-3 p-3 bg-slate-100 dark:bg-slate-700/50 rounded-lg">
                    <p class="text-sm text-slate-600 dark:text-slate-300">Please add your Gemini API key in <a href="#" id="go-to-settings-link" class="font-semibold text-sky-500 hover:underline">Settings</a> to use this feature.</p>
                </div>
            </div>

        </div>

        <!-- Settings Screen -->
        <div id="settings-screen" class="app-screen bg-white dark:bg-slate-800 rounded-2xl shadow-xl p-6 md:p-8">
            <div class="flex items-center mb-6">
                <button id="back-to-main-view-btn-settings" class="text-slate-400 hover:text-sky-500 mr-3">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M15 19l-7-7 7-7" /></svg>
                </button>
                <h2 class="text-xl font-bold text-slate-800 dark:text-white">Settings</h2>
            </div>
            <div class="space-y-4">
                <div>
                    <label for="gemini-api-key" class="block text-sm font-medium text-slate-700 dark:text-slate-200 mb-1">Gemini API Key</label>
                    <input type="password" id="gemini-api-key" placeholder="Enter your API key" class="w-full p-2 border border-slate-300 dark:border-slate-600 rounded-lg bg-white dark:bg-slate-700 focus:ring-2 focus:ring-sky-500 focus:outline-none">
                    <p class="text-xs text-slate-500 mt-1">To get an API key, <a href="https://aistudio.google.com/app/apikey" target="_blank" rel="noopener noreferrer" class="text-sky-500 hover:underline">click here</a>. Your key is stored securely in your browser's local storage.</p>
                </div>
                <div class="flex space-x-2">
                    <button id="save-api-key-btn" class="w-full bg-sky-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-sky-600">Save Key</button>
                    <button id="delete-api-key-btn" class="w-full bg-red-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-600">Delete Key</button>
                </div>
                 <p id="api-key-status" class="text-sm text-center text-green-600 dark:text-green-400"></p>
            </div>
        </div>
    </div>
    
    <!-- Add/Edit Card Modal -->
    <div id="card-editor-modal" class="hidden fixed inset-0 bg-slate-900 bg-opacity-60 flex items-center justify-center p-4 z-50">
        <form id="card-editor-form" class="bg-white dark:bg-slate-800 rounded-2xl shadow-xl p-6 md:p-8 w-full max-w-md">
            <h3 id="card-editor-title" class="text-lg font-semibold text-slate-700 dark:text-slate-200 mb-3">Add New Card</h3>
            <div class="space-y-3">
                <textarea id="edit-question" placeholder="Question / Term" rows="2" class="w-full p-2 border border-slate-300 dark:border-slate-600 rounded-lg bg-white dark:bg-slate-700 focus:ring-2 focus:ring-sky-500 focus:outline-none"></textarea>
                <textarea id="edit-answer" placeholder="Answer / Definition" rows="3" class="w-full p-2 border border-slate-300 dark:border-slate-600 rounded-lg bg-white dark:bg-slate-700 focus:ring-2 focus:ring-sky-500 focus:outline-none"></textarea>
                <textarea id="edit-explanation" placeholder="Optional: Fuller Explanation" rows="4" class="w-full p-2 border border-slate-300 dark:border-slate-600 rounded-lg bg-white dark:bg-slate-700 focus:ring-2 focus:ring-sky-500 focus:outline-none"></textarea>
            </div>
             <div class="flex items-center space-x-2 mt-4">
                <button type="submit" id="save-card-btn" class="w-full bg-sky-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-sky-600 active:scale-95">Add Card</button>
                <button type="button" id="cancel-edit-btn" class="w-full bg-slate-200 dark:bg-slate-600 text-slate-800 dark:text-slate-200 font-bold py-2 px-4 rounded-lg hover:bg-slate-300 dark:hover:bg-slate-500">Cancel</button>
             </div>
        </form>
    </div>

    <!-- Confirmation Modal -->
    <div id="confirmation-modal" class="hidden fixed inset-0 bg-slate-900 bg-opacity-60 flex items-center justify-center p-4 z-50">
        <div class="bg-white dark:bg-slate-800 rounded-2xl shadow-xl p-6 md:p-8 w-full max-w-sm text-center">
            <div class="mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-red-100 dark:bg-red-900/50">
                <svg class="h-6 w-6 text-red-600 dark:text-red-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126z" />
                </svg>
            </div>
            <h3 class="text-lg font-medium leading-6 text-slate-900 dark:text-white mt-5">Are you sure?</h3>
            <div class="mt-2">
                <p id="confirmation-message" class="text-sm text-slate-500 dark:text-slate-400"></p>
            </div>
            <div class="mt-5 sm:mt-6 grid grid-cols-2 gap-3">
                <button type="button" id="confirm-delete-btn" class="w-full justify-center rounded-md border border-transparent bg-red-600 px-4 py-2 text-base font-medium text-white shadow-sm hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 dark:ring-offset-slate-800">Delete</button>
                <button type="button" id="cancel-delete-btn" class="w-full justify-center rounded-md border border-slate-300 dark:border-slate-600 bg-white dark:bg-slate-700 px-4 py-2 text-base font-medium text-slate-700 dark:text-slate-200 shadow-sm hover:bg-slate-50 dark:hover:bg-slate-600 focus:outline-none focus:ring-2 focus:ring-sky-500 focus:ring-offset-2 dark:ring-offset-slate-800">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Warning Modal -->
    <div id="warning-modal" class="hidden fixed inset-0 bg-slate-900 bg-opacity-60 flex items-center justify-center p-4 z-50">
        <div class="bg-white dark:bg-slate-800 rounded-2xl shadow-xl p-6 md:p-8 w-full max-w-sm text-center">
            <div class="mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-amber-100 dark:bg-amber-900/50">
                <svg class="h-6 w-6 text-amber-600 dark:text-amber-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                     <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126z" />
                </svg>
            </div>
            <h3 class="text-lg font-medium leading-6 text-slate-900 dark:text-white mt-5">Import Warning</h3>
            <div class="mt-2 text-left">
                <p id="warning-message" class="text-sm text-slate-500 dark:text-slate-400"></p>
            </div>
            <div class="mt-5 sm:mt-6">
                <button type="button" id="close-warning-btn" class="w-full justify-center rounded-md border border-transparent bg-sky-600 px-4 py-2 text-base font-medium text-white shadow-sm hover:bg-sky-700 focus:outline-none focus:ring-2 focus:ring-sky-500 focus:ring-offset-2 dark:ring-offset-slate-800">OK</button>
            </div>
        </div>
    </div>


    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- Libraries & Constants ---
        const { JSZip, jsyaml } = window;
        if (!window.tsfsrs || !JSZip || !jsyaml) { 
            document.body.innerHTML = `<div class="w-full max-w-md mx-auto my-8 p-6 bg-white dark:bg-slate-800 rounded-lg shadow-md text-center"><h1 class="text-2xl font-bold text-red-600 dark:text-red-400">Initialization Error</h1><p class="mt-2 text-slate-700 dark:text-slate-200">Could not load required libraries. Please check your internet connection and refresh.</p></div>`;
            return; 
        }
        const { fsrs, generatorParameters, Rating, createEmptyCard } = window.tsfsrs;
        const DECKS_STORAGE_KEY = 'flashcard-app-decks-v4', API_KEY_STORAGE_KEY = 'flashcard-app-gemini-api-key', LEARNING_HISTORY_STORAGE_KEY = 'flashcard-app-learning-history-v2';
        
        let decks = {}, learningHistory = [], activeDeckId = null, currentCardIndex = 0, isFlipped = false, editingCardIndex = null, geminiApiKey = '', confirmCallback = null;
        const f = fsrs(generatorParameters());

        // --- DOM Elements ---
        const screens = { mainView: document.getElementById('main-view-screen'), mainDeck: document.getElementById('main-deck-screen'), manageCards: document.getElementById('manage-cards-screen'), settings: document.getElementById('settings-screen') };
        const tabDecks = document.getElementById('tab-decks'), tabSchedule = document.getElementById('tab-schedule'), tabLearning = document.getElementById('tab-learning'), tabContentDecks = document.getElementById('tab-content-decks'), tabContentSchedule = document.getElementById('tab-content-schedule'), tabContentLearning = document.getElementById('tab-content-learning');
        const decksContainer = document.getElementById('decks-container'), createDeckForm = document.getElementById('create-deck-form'), newDeckNameInput = document.getElementById('new-deck-name'), downloadBtn = document.getElementById('download-decks-btn'), uploadBtn = document.getElementById('upload-decks-btn'), uploadInput = document.getElementById('deck-upload-input'), settingsBtn = document.getElementById('settings-btn');
        const scheduleContainer = document.getElementById('schedule-container');
        const learningHistoryContainer = document.getElementById('learning-history-container'), downloadHistoryBtn = document.getElementById('download-history-btn'), uploadHistoryBtn = document.getElementById('upload-history-btn'), historyUploadInput = document.getElementById('history-upload-input'), learningSearchInput = document.getElementById('learning-search-input');
        const cardQuestion = document.getElementById('card-question'), cardAnswer = document.getElementById('card-answer'), cardFront = document.getElementById('card-front'), cardBack = document.getElementById('card-back'), noCardsMessage = document.getElementById('no-cards-message'), progressBar = document.getElementById('progress-bar'), progressText = document.getElementById('progress-text'), showAnswerBtn = document.getElementById('show-answer-btn'), showAnswerContainer = document.getElementById('show-answer-container'), ratingContainer = document.getElementById('rating-container'), ratingButtons = document.querySelectorAll('.rating-btn'), flashcardDeck = document.getElementById('flashcard-deck'), completionScreen = document.getElementById('completion-screen'), restartBtn = document.getElementById('restart-btn'), showExplanationBtn = document.getElementById('show-explanation-btn'), explanationContainer = document.getElementById('explanation-container'), cardExplanation = document.getElementById('card-explanation');
        const addCardBtn = document.getElementById('add-card-btn'), cardEditorModal = document.getElementById('card-editor-modal'), cardEditorForm = document.getElementById('card-editor-form'), cardEditorTitle = document.getElementById('card-editor-title'), editQuestion = document.getElementById('edit-question'), editAnswer = document.getElementById('edit-answer'), editExplanation = document.getElementById('edit-explanation'), saveCardBtn = document.getElementById('save-card-btn'), cancelEditBtn = document.getElementById('cancel-edit-btn'), cardsListContainer = document.getElementById('cards-list'), deckTitleStudy = document.getElementById('deck-title-study'), deckTitleManage = document.getElementById('deck-title-manage');
        const aiGenerationContainer = document.getElementById('ai-generation-container'), aiNeedsKeyMessage = document.getElementById('ai-needs-key-message'), goToSettingsLink = document.getElementById('go-to-settings-link'), generateCardsBtn = document.getElementById('generate-cards-btn'), aiTopicInput = document.getElementById('ai-topic'), aiCardCountInput = document.getElementById('ai-card-count'), aiError = document.getElementById('ai-error');
        const geminiApiKeyInput = document.getElementById('gemini-api-key'), saveApiKeyBtn = document.getElementById('save-api-key-btn'), deleteApiKeyBtn = document.getElementById('delete-api-key-btn'), apiKeyStatus = document.getElementById('api-key-status'), backToMainFromCompleteBtn = document.getElementById('back-to-main-from-complete-btn');
        const confirmationModal = document.getElementById('confirmation-modal'), confirmationMessage = document.getElementById('confirmation-message'), confirmDeleteBtn = document.getElementById('confirm-delete-btn'), cancelDeleteBtn = document.getElementById('cancel-delete-btn');
        const warningModal = document.getElementById('warning-modal'), warningMessage = document.getElementById('warning-message'), closeWarningBtn = document.getElementById('close-warning-btn');

        // --- Navigation & Modals ---
        const showScreen = name => { 
            Object.values(screens).forEach(s => s.classList.remove('active')); 
            if (screens[name]) { 
                screens[name].classList.add('active'); 
                if (name === 'manageCards') updateAiFeatureAvailability(); 
                else if (name === 'mainView') { renderDeckList(); renderLearningHistory(); renderSchedule(); } 
            } 
        };
        const showTab = (tabName) => { 
            tabDecks.classList.toggle('active', tabName === 'decks'); 
            tabSchedule.classList.toggle('active', tabName === 'schedule');
            tabLearning.classList.toggle('active', tabName === 'learning'); 
            tabContentDecks.classList.toggle('active', tabName === 'decks'); 
            tabContentSchedule.classList.toggle('active', tabName === 'schedule');
            tabContentLearning.classList.toggle('active', tabName === 'learning'); 
            if(tabName === 'schedule') renderSchedule();
        };
        const showConfirmationModal = (message, onConfirm) => { 
            confirmationMessage.textContent = message; 
            confirmCallback = onConfirm; 
            confirmationModal.classList.remove('hidden'); 
        };
        const hideConfirmationModal = () => { 
            confirmationModal.classList.add('hidden'); 
            confirmCallback = null; 
        };
        const showWarningModal = (message) => { 
            warningMessage.innerHTML = message; 
            warningModal.classList.remove('hidden'); 
        };
        confirmDeleteBtn.addEventListener('click', () => { 
            if (typeof confirmCallback === 'function') confirmCallback(); 
            hideConfirmationModal(); 
        });
        cancelDeleteBtn.addEventListener('click', hideConfirmationModal);
        closeWarningBtn.addEventListener('click', () => warningModal.classList.add('hidden'));

        tabDecks.addEventListener('click', () => showTab('decks')); 
        tabSchedule.addEventListener('click', () => showTab('schedule'));
        tabLearning.addEventListener('click', () => showTab('learning'));
        document.getElementById('back-to-main-view-btn-study').addEventListener('click', () => showScreen('mainView'));
        document.getElementById('back-to-main-view-btn-manage').addEventListener('click', () => showScreen('mainView'));
        document.getElementById('back-to-main-view-btn-manage-done').addEventListener('click', () => showScreen('mainView'));
        document.getElementById('back-to-main-view-btn-settings').addEventListener('click', () => showScreen('mainView'));
        settingsBtn.addEventListener('click', () => showScreen('settings'));

        // --- Data Management ---
        const generateUUID = () => crypto.randomUUID();
        
        function loadDecks() {
            const storedDecks = localStorage.getItem(DECKS_STORAGE_KEY);
            try {
                if (storedDecks) {
                    decks = JSON.parse(storedDecks);
                    let wasModified = false;
                    Object.values(decks).forEach(deck => {
                        if (!deck.id || !deck.id.includes('-')) { 
                            deck.id = generateUUID(); 
                            wasModified = true; 
                        }
                        deck.cards.forEach(card => { 
                            if (!card.id || !card.id.includes('-')) { 
                                card.id = generateUUID(); 
                                wasModified = true; 
                            } 
                        });
                    });
                    if (wasModified) saveDecks();
                } else {
                    decks = {};
                }
            } catch (e) { 
                console.error("Failed to parse decks.", e); 
                decks = {}; 
                localStorage.removeItem(DECKS_STORAGE_KEY); 
            }
        }
        
        const saveDecks = () => localStorage.setItem(DECKS_STORAGE_KEY, JSON.stringify(decks));
        
        function loadLearningHistory() {
            const storedHistory = localStorage.getItem(LEARNING_HISTORY_STORAGE_KEY);
            try { 
                if (storedHistory) learningHistory = JSON.parse(storedHistory); 
                else learningHistory = []; 
            } catch (e) {
                console.error("Failed to parse learning history.", e); 
                learningHistory = []; 
                localStorage.removeItem(LEARNING_HISTORY_STORAGE_KEY);
            }
        }

        const saveLearningHistory = () => localStorage.setItem(LEARNING_HISTORY_STORAGE_KEY, JSON.stringify(learningHistory));
        
        function loadApiKey() {
            geminiApiKey = localStorage.getItem(API_KEY_STORAGE_KEY) || '';
            geminiApiKeyInput.value = geminiApiKey;
        }

        function saveApiKey() {
            geminiApiKey = geminiApiKeyInput.value.trim();
            if (geminiApiKey) {
                localStorage.setItem(API_KEY_STORAGE_KEY, geminiApiKey);
            } else {
                localStorage.removeItem(API_KEY_STORAGE_KEY);
            }
            apiKeyStatus.textContent = geminiApiKey ? 'API Key saved!' : 'API Key cleared.';
            setTimeout(() => apiKeyStatus.textContent = '', 2000);
        }

        function deleteApiKey() {
            localStorage.removeItem(API_KEY_STORAGE_KEY); 
            geminiApiKey = ''; 
            geminiApiKeyInput.value = '';
            apiKeyStatus.textContent = 'API Key deleted.'; 
            setTimeout(() => apiKeyStatus.textContent = '', 2000);
        }

        saveApiKeyBtn.addEventListener('click', saveApiKey); 
        deleteApiKeyBtn.addEventListener('click', deleteApiKey);

        // --- Deck List UI ---
        function renderDeckList() {
            decksContainer.innerHTML = ''; 
            const deckIds = Object.keys(decks);
            if (deckIds.length === 0) {
                 decksContainer.innerHTML = `<p class="text-center text-slate-500 dark:text-slate-400">No decks yet, create or upload!</p>`; 
                 return;
            }
            deckIds.forEach(id => {
                const deck = decks[id]; 
                const deckEl = document.createElement('div');
                deckEl.className = 'bg-slate-50 dark:bg-slate-700/50 p-3 rounded-lg flex items-center space-x-3 transition-all duration-300';
                deckEl.setAttribute('data-deck-id', id);
                deckEl.innerHTML = `<input type="checkbox" data-deck-id="${deck.id}" class="deck-checkbox h-5 w-5 rounded border-slate-300 text-sky-600 focus:ring-sky-500"><div class="flex-grow min-w-0 cursor-pointer study-deck-area" data-deck-id="${deck.id}"><p class="font-bold text-slate-800 dark:text-slate-100 truncate pointer-events-none">${deck.name}</p><p class="text-sm text-slate-500 dark:text-slate-400 pointer-events-none">${deck.cards.length} cards</p></div><div class="flex items-center space-x-2"><button data-deck-id="${deck.id}" class="rename-deck-btn text-slate-500 hover:text-sky-500 p-1"><svg class="h-5 w-5 pointer-events-none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z" /></svg></button><button data-deck-id="${deck.id}" class="edit-deck-btn text-slate-500 hover:text-sky-500 p-1"><svg class="h-5 w-5 pointer-events-none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path d="M17.414 2.586a2 2 0 00-2.828 0L7 10.172V13h2.828l7.586-7.586a2 2 0 000-2.828z" /><path fill-rule="evenodd" d="M2 6a2 2 0 012-2h4a1 1 0 010 2H4v10h10v-4a1 1 0 112 0v4a2 2 0 01-2 2H4a2 2 0 01-2-2V6z" clip-rule="evenodd" /></svg></button><button data-deck-id="${deck.id}" class="delete-deck-btn text-slate-500 hover:text-red-500 p-1"><svg class="h-5 w-5 pointer-events-none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" /></svg></button></div>`;
                decksContainer.appendChild(deckEl);
            });
        }

        function handleDeckListActions(e) {
            const target = e.target;
            if (target.classList.contains('deck-checkbox')) {
                downloadBtn.disabled = !decksContainer.querySelectorAll('.deck-checkbox:checked').length; 
                return;
            }
            const deckItem = target.closest('[data-deck-id]'); 
            if (!deckItem) return;
            const deckId = deckItem.dataset.deckId;
            if (target.closest('.study-deck-area')) {
                activeDeckId = deckId; 
                deckTitleStudy.textContent = decks[activeDeckId].name;
                restartSession(); 
                showScreen('mainDeck');
            } else if (target.closest('.edit-deck-btn')) {
                activeDeckId = deckId; 
                deckTitleManage.textContent = decks[activeDeckId].name;
                renderManageList(); 
                showScreen('manageCards');
            } else if (target.closest('.rename-deck-btn')) {
                const oldName = decks[deckId].name; 
                const newName = prompt('Enter new deck name:', oldName);
                if (newName && newName.trim() && newName.trim() !== oldName) {
                    decks[deckId].name = newName.trim(); 
                    saveDecks(); 
                    renderDeckList();
                }
            } else if (target.closest('.delete-deck-btn')) {
                const message = `This will permanently delete the "${decks[deckId].name}" deck and all its learning history. This action cannot be undone.`;
                showConfirmationModal(message, () => {
                    learningHistory = learningHistory.filter(record => record.deckId !== deckId);
                    saveLearningHistory();
                    delete decks[deckId];
                    saveDecks();
                    renderDeckList();
                });
            }
        }

        createDeckForm.addEventListener('submit', (e) => { 
            e.preventDefault(); 
            const name = newDeckNameInput.value.trim(); 
            if (name) { 
                const id = generateUUID(); 
                decks[id] = { id, name, cards: [] }; 
                saveDecks(); 
                renderDeckList(); 
                newDeckNameInput.value = ''; 
            } 
        });

        // --- Import/Export ---
        downloadBtn.addEventListener('click', async () => {
            const selectedIds = [...decksContainer.querySelectorAll('.deck-checkbox:checked')].map(cb => cb.dataset.deckId);
            if (selectedIds.length === 0) return;
            const zip = new JSZip();
            selectedIds.forEach(id => {
                const deck = decks[id]; const yamlString = jsyaml.dump(deck);
                zip.file(`${deck.name.replace(/[^a-z0-9]/gi, '_')}.yaml`, yamlString);
            });
            const content = await zip.generateAsync({ type: 'blob' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(content); link.download = 'flashcard_decks.zip';
            link.click(); URL.revokeObjectURL(link.href);
        });

        uploadBtn.addEventListener('click', () => uploadInput.click());

        uploadInput.addEventListener('change', async (e) => {
            const file = e.target.files[0]; if (!file) return;

            const existingDeckIds = new Set(Object.keys(decks));
            const existingCardIds = new Set(Object.values(decks).flatMap(d => d.cards.map(c => c.id)));
            const ignoredDecks = [];
            const addedDecks = {};

            const zip = await JSZip.loadAsync(file);
            for (const filename in zip.files) {
                if (filename.endsWith('.yaml') || filename.endsWith('.yml')) {
                    const fileContent = await zip.files[filename].async('string');
                    try {
                        let importedDeck = jsyaml.load(fileContent);
                        if (importedDeck && importedDeck.id && importedDeck.name && Array.isArray(importedDeck.cards)) {
                            let hasConflict = false;
                            if (existingDeckIds.has(importedDeck.id)) {
                                hasConflict = true;
                            } else {
                                for (const card of importedDeck.cards) {
                                    if (existingCardIds.has(card.id)) {
                                        hasConflict = true;
                                        break;
                                    }
                                }
                            }
                            if (hasConflict) {
                                ignoredDecks.push(importedDeck.name);
                            } else {
                                addedDecks[importedDeck.id] = importedDeck;
                                existingDeckIds.add(importedDeck.id);
                                importedDeck.cards.forEach(card => existingCardIds.add(card.id));
                            }
                        }
                    } catch (err) { console.error(`Failed to parse ${filename}:`, err); }
                }
            }

            if (Object.keys(addedDecks).length > 0) {
                Object.assign(decks, addedDecks);
                saveDecks();
                renderDeckList();
            }

            if (ignoredDecks.length > 0) {
                const message = `The following decks were not imported due to ID conflicts: <ul>${ignoredDecks.map(name => `<li class='mt-1 ml-4 list-disc'>${name}</li>`).join('')}</ul>`;
                showWarningModal(message);
            }

            e.target.value = '';
        });
        
        // --- GEMINI API ---
        async function callGemini(payload) {
            const apiKey = geminiApiKey || ''; if (!apiKey) throw new Error("Gemini API key not found.");
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
            try {
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (response.status === 400) throw new Error("Invalid API Key. Please check your key in Settings.");
                else if (response.status === 429) throw new Error("API quota exceeded. Please check your usage in the Google AI Studio.");
                else if (!response.ok) throw new Error(`API Error: ${response.status}`);
                const result = await response.json(); const text = result.candidates?.[0]?.content?.parts?.[0]?.text;
                if (!text) throw new Error("No content received from API.");
                return text;
            } catch (error) { console.error("Error calling Gemini API:", error); throw error; }
        }
        
        // --- Main Deck Functions ---
        function updateProgress() {
            const cards = decks[activeDeckId]?.cards || [];
            progressBar.style.width = cards.length === 0 ? '0%' : `${(currentCardIndex / cards.length) * 100}%`;
            progressText.textContent = `${currentCardIndex} / ${cards.length}`;
        }
        function displayCard(index) {
            const cards = decks[activeDeckId]?.cards || [];
            const hasCards = cards.length > 0;
            noCardsMessage.classList.toggle('hidden', hasCards); 
            cardFront.classList.toggle('hidden', !hasCards);
            showAnswerContainer.classList.toggle('hidden', !hasCards);
            if (!hasCards) { 
                updateProgress(); 
                return; 
            }
            if (index >= cards.length) { 
                showCompletionScreen(); 
                return; 
            }
            const card = cards[index];
            cardQuestion.textContent = card.question; 
            cardAnswer.textContent = card.answer;
            cardExplanation.textContent = card.explanation || '';
            showExplanationBtn.classList.toggle('hidden', !card.explanation);
            updateProgress(); 
            resetCardState();
        }
        function flipCard() {
            if (!activeDeckId || decks[activeDeckId].cards.length === 0) return;
            isFlipped = true; 
            cardFront.classList.add('hidden'); 
            cardBack.classList.add('visible');
            showAnswerContainer.classList.add('hidden'); 
            ratingContainer.classList.remove('hidden');
        }
        function resetCardState() {
            isFlipped = false; 
            cardFront.classList.remove('hidden'); 
            cardBack.classList.remove('visible');
            showAnswerContainer.classList.remove('hidden'); 
            ratingContainer.classList.add('hidden');
            explanationContainer.classList.remove('visible'); 
            showExplanationBtn.textContent = 'Show Explanation';
        }
        function handleRating(e) {
            const rating = e.target.dataset.rating;
            const currentCard = decks[activeDeckId].cards[currentCardIndex];
            const record = { 
                id: generateUUID(), 
                deckId: activeDeckId, 
                deckName: decks[activeDeckId].name, 
                cardId: currentCard.id, 
                cardQuestion: currentCard.question, 
                timestamp: new Date().toISOString(), 
                rating: rating 
            };
            learningHistory.unshift(record); 
            saveLearningHistory();
            currentCardIndex++; 
            displayCard(currentCardIndex); 
        }
        function showCompletionScreen() { 
            flashcardDeck.classList.add('hidden'); 
            completionScreen.classList.remove('hidden'); 
        }
        function restartSession() { 
            currentCardIndex = 0; 
            completionScreen.classList.add('hidden');
            flashcardDeck.classList.remove('hidden'); 
            displayCard(currentCardIndex); 
        }
        function startSessionAtIndex(index) {
            currentCardIndex = index;
            completionScreen.classList.add('hidden');
            flashcardDeck.classList.remove('hidden');
            displayCard(currentCardIndex);
        }
        showExplanationBtn.addEventListener('click', () => { 
            explanationContainer.classList.toggle('visible'); 
            showExplanationBtn.textContent = explanationContainer.classList.contains('visible') ? 'Hide Explanation' : 'Show Explanation'; 
        });

        // --- Manage Cards UI & Modal ---
        function openModal() { cardEditorModal.classList.remove('hidden'); }
        function closeModal() { cardEditorModal.classList.add('hidden'); resetCardEditor(); }
        function renderManageList() {
            cardsListContainer.innerHTML = ''; 
            const cards = decks[activeDeckId]?.cards || [];
            if (cards.length === 0) {
                cardsListContainer.innerHTML = `<p class="text-sm text-slate-400">This deck is empty. Add or generate cards!</p>`; 
                return;
            }
            cards.forEach((card, index) => {
                const cardEl = document.createElement('div');
                cardEl.className = 'bg-slate-50 dark:bg-slate-700/50 p-3 rounded-lg flex justify-between items-start cursor-pointer hover:bg-slate-100 dark:hover:bg-slate-700';
                cardEl.dataset.index = index;
                cardEl.innerHTML = `<div class="pr-4 overflow-hidden"><p class="font-semibold text-sm text-slate-800 dark:text-slate-100 truncate">${card.question}</p><p class="text-xs text-slate-500 dark:text-slate-400 mt-1 truncate">${card.answer}</p></div><button data-index="${index}" class="delete-card-btn flex-shrink-0 text-red-500 hover:text-red-700 p-1"><svg class="h-5 w-5 pointer-events-none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" /></svg></button>`;
                cardsListContainer.appendChild(cardEl);
            });
        }
        function handleCardListClick(e) {
            const deleteBtn = e.target.closest('.delete-card-btn');
            if (deleteBtn) {
                const index = parseInt(deleteBtn.dataset.index, 10);
                const card = decks[activeDeckId].cards[index];
                const message = `This will permanently delete the card "${card.question}" and its learning history. This action cannot be undone.`;
                showConfirmationModal(message, () => {
                    learningHistory = learningHistory.filter(record => record.cardId !== card.id);
                    saveLearningHistory();
                    decks[activeDeckId].cards.splice(index, 1);
                    saveDecks();
                    renderManageList();
                });
            } else {
                const cardEl = e.target.closest('[data-index]');
                if (cardEl) { 
                    populateCardEditor(parseInt(cardEl.dataset.index, 10)); 
                    openModal(); 
                }
            }
        }
        function populateCardEditor(index) {
            const card = decks[activeDeckId].cards[index];
            editingCardIndex = index; 
            cardEditorTitle.textContent = 'Edit Card';
            editQuestion.value = card.question; 
            editAnswer.value = card.answer; 
            editExplanation.value = card.explanation || '';
            saveCardBtn.textContent = 'Update Card';
        }
        function resetCardEditor() {
            editingCardIndex = null; 
            cardEditorForm.reset();
            cardEditorTitle.textContent = 'Add New Card'; 
            saveCardBtn.textContent = 'Add Card';
        }
        cardEditorForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const question = editQuestion.value.trim(), answer = editAnswer.value.trim(), explanation = editExplanation.value.trim();
            if (!question || !answer) return;
            if (editingCardIndex !== null) {
                const card = decks[activeDeckId].cards[editingCardIndex];
                card.question = question; 
                card.answer = answer; 
                card.explanation = explanation;
            } else {
                decks[activeDeckId].cards.unshift({ id: generateUUID(), question, answer, explanation });
            }
            saveDecks(); 
            renderManageList(); 
            closeModal();
        });
        addCardBtn.addEventListener('click', () => { resetCardEditor(); openModal(); });
        cancelEditBtn.addEventListener('click', closeModal);
        cardEditorModal.addEventListener('click', (e) => { if (e.target === cardEditorModal) closeModal(); });

        // --- AI Feature Handlers ---
        function updateAiFeatureAvailability() {
            const hasApiKey = !!geminiApiKey;
            aiGenerationContainer.querySelectorAll('input, button').forEach(el => el.disabled = !hasApiKey);
            aiNeedsKeyMessage.classList.toggle('hidden', hasApiKey);
        }
        async function handleGenerateCards(e) {
            e.preventDefault();
            const topic = aiTopicInput.value.trim(), count = parseInt(aiCardCountInput.value, 10) || 10;
            if (!topic || !activeDeckId || count < 1) return;
            generateCardsBtn.disabled = true; 
            generateCardsBtn.innerHTML = `<svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg> Generating...`;
            aiError.classList.add('hidden');
            const schema = { type: "ARRAY", items: { type: "OBJECT", properties: { "question": { "type": "STRING" }, "answer": { "type": "STRING" }, "explanation": { "type": "STRING" }}, required: ["question", "answer"] } };
            const prompt = `Generate ${count} flashcards for the topic "${topic}". For each card, provide a "question", a concise "answer", and an "explanation". The explanation should be a fuller, more detailed description of the answer, but leave it as an empty string if the term is simple vocabulary where no explanation is needed.`;
            const payload = { contents: [{ parts: [{ text: prompt }] }], generationConfig: { responseMimeType: "application/json", responseSchema: schema } };
            try {
                const resultText = await callGemini(payload); 
                const newCards = JSON.parse(resultText);
                const processedCards = newCards.map(card => ({...card, id: generateUUID()}));
                decks[activeDeckId].cards.unshift(...processedCards);
                saveDecks(); 
                renderManageList(); 
                aiTopicInput.value = '';
            } catch (error) {
                aiError.textContent = `Could not generate cards. ${error.message}`; 
                aiError.classList.remove('hidden');
            } finally {
                generateCardsBtn.disabled = false; 
                generateCardsBtn.textContent = 'Generate Cards';
            }
        }

        // --- FSRS Scheduling Functions ---
        const mapRatingToFSRSRating = (rating) => {
            switch (rating.toLowerCase()) {
                case 'again': return Rating.Again;
                case 'hard': return Rating.Hard;
                case 'good': return Rating.Good;
                case 'easy': return Rating.Easy;
                default: return Rating.Again;
            }
        };

        const groupReviewsByItem = (rawReviews) => {
            const itemsMap = new Map();
            rawReviews.forEach(review => {
                const { cardId, deckId, deckName, cardQuestion, timestamp, rating } = review;
                if (!itemsMap.has(cardId)) {
                    itemsMap.set(cardId, {
                        id: cardId, deckId: deckId, deckName: deckName,
                        cardQuestion: cardQuestion, history: [],
                    });
                }
                itemsMap.get(cardId).history.push({ timestamp, rating });
            });
            return Array.from(itemsMap.values());
        };

        const calculateItemStateWithFSRS = (history) => {
            let card = createEmptyCard();
            history.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
            history.forEach((review) => {
                const reviewDate = new Date(review.timestamp);
                const rating = mapRatingToFSRSRating(review.rating);
                const scheduling_cards = f.repeat(card, reviewDate);
                card = scheduling_cards[rating].card;
            });
            return card;
        };
        
        const rankAndColorItems = (allItems) => {
            const now = new Date();
            const itemsWithStatus = allItems.map(item => {
                const { history } = item;
                if (history.length === 0) {
                    return { ...item, color: 'red', p_recall: 0, next_review: now };
                }
                const fsrsCard = calculateItemStateWithFSRS(history);
                if (!fsrsCard.last_review) {
                    return { ...item, color: 'red', p_recall: 0, next_review: now };
                }

                const p_recall = f.get_retrievability(fsrsCard, now) || 0;

                let color;
                if (p_recall < 0.80) { // Overdue
                    color = 'red';
                } else if (p_recall < 0.95) { // Optimal
                    color = 'green';
                } else { // Premature
                    color = 'blue';
                }
                
                const scheduling_cards = f.repeat(fsrsCard, now);
                const nextReviewDate = scheduling_cards && scheduling_cards[Rating.Good] ? scheduling_cards[Rating.Good].card.due : now;


                return { ...item, color, p_recall, next_review: nextReviewDate };
            });

            itemsWithStatus.sort((a, b) => a.p_recall - b.p_recall);
            return itemsWithStatus;
        };


        // --- Schedule & Learning History ---
        function renderSchedule() {
            scheduleContainer.innerHTML = '';
            const items = groupReviewsByItem(learningHistory);
            const rankedItems = rankAndColorItems(items);

            if (rankedItems.length === 0) {
                scheduleContainer.innerHTML = `<p class="text-center text-slate-500 dark:text-slate-400">No cards with learning history yet. Study some cards to build your schedule!</p>`;
                return;
            }

            const table = document.createElement('table'); 
            table.className = 'w-full text-sm text-left table-fixed';
            table.innerHTML = `<thead class="text-xs text-slate-700 uppercase bg-slate-50 dark:bg-slate-700 dark:text-slate-400"><tr><th scope="col" class="px-4 py-3">Card</th><th scope="col" class="px-4 py-3 text-right">Next Review</th></tr></thead>`;
            const tbody = document.createElement('tbody');
            rankedItems.forEach(item => {
                const tr = document.createElement('tr'); 
                tr.className = 'border-b dark:border-slate-700';
                const nextDate = item.next_review ? item.next_review.toLocaleDateString() : 'N/A';
                tr.innerHTML = `
                    <td class="px-4 py-3">
                        <p class="font-medium truncate cursor-pointer hover:underline schedule-card-link schedule-color-${item.color}" data-deck-id="${item.deckId}" data-card-id="${item.id}" title="Study from this card">${item.cardQuestion}</p>
                        <p class="text-xs text-slate-500 dark:text-slate-400">in <span class="font-semibold cursor-pointer hover:underline schedule-deck-link" data-deck-id="${item.deckId}" title="Study this deck">${item.deckName}</span></p>
                    </td>
                    <td class="px-4 py-3 text-right text-slate-500 dark:text-slate-400">
                        <p class="font-semibold">${Math.round(item.p_recall * 100)}%</p>
                        <p class="text-xs">${nextDate}</p>
                    </td>
                `;
                tbody.appendChild(tr);
            });
            table.appendChild(tbody); 
            scheduleContainer.appendChild(table);
        }

        function renderLearningHistory(searchTerm = '') {
            learningHistoryContainer.innerHTML = '';
            const normalizedSearchTerm = searchTerm.trim().toLowerCase();
            const filteredHistory = learningHistory.filter(r => r.deckName.toLowerCase().includes(normalizedSearchTerm) || r.cardQuestion.toLowerCase().includes(normalizedSearchTerm));
            if (filteredHistory.length === 0) {
                learningHistoryContainer.innerHTML = `<p class="text-center text-slate-500 dark:text-slate-400">${searchTerm ? `No results for "${searchTerm}".` : 'No learning history yet.'}</p>`;
                return;
            }
            const table = document.createElement('table'); 
            table.className = 'w-full text-sm text-left table-fixed';
            table.innerHTML = `<thead class="text-xs text-slate-700 uppercase bg-slate-50 dark:bg-slate-700 dark:text-slate-400"><tr><th scope="col" class="px-4 py-3">Details</th><th scope="col" class="px-4 py-3 text-right">Rating</th></tr></thead>`;
            const tbody = document.createElement('tbody');
            filteredHistory.forEach(record => {
                const tr = document.createElement('tr'); 
                tr.className = 'border-b dark:border-slate-700';
                const date = new Date(record.timestamp).toLocaleString();
                tr.innerHTML = `
                    <td class="px-4 py-3">
                        <p class="font-medium text-slate-900 dark:text-white truncate cursor-pointer hover:text-sky-500 study-card-link" data-deck-id="${record.deckId}" data-card-id="${record.cardId}" title="Study from this card">${record.cardQuestion}</p>
                        <p class="text-xs text-slate-500 dark:text-slate-400">in <span class="font-semibold cursor-pointer hover:underline study-deck-link" data-deck-id="${record.deckId}" title="Study this deck">${record.deckName}</span></p>
                        <p class="text-xs text-slate-400 dark:text-slate-500 mt-1">${date}</p>
                    </td>
                    <td class="px-4 py-3 font-semibold capitalize text-right">${record.rating}</td>
                `;
                tbody.appendChild(tr);
            });
            table.appendChild(tbody); 
            learningHistoryContainer.appendChild(table);
        }

        function handleStudyLinkClicks(e) {
            const cardLink = e.target.closest('.study-card-link, .schedule-card-link');
            const deckLink = e.target.closest('.study-deck-link, .schedule-deck-link');

            if (cardLink) {
                const deckId = cardLink.dataset.deckId;
                const cardId = cardLink.dataset.cardId;
                if (decks[deckId]) {
                    const cardIndex = decks[deckId].cards.findIndex(c => c.id === cardId);
                    if (cardIndex !== -1) {
                        activeDeckId = deckId;
                        deckTitleStudy.textContent = decks[deckId].name;
                        startSessionAtIndex(cardIndex);
                        showScreen('mainDeck');
                    } else {
                        showWarningModal('This card no longer exists in the deck.');
                    }
                } else {
                    showWarningModal('This deck no longer exists.');
                }
            } else if (deckLink) {
                const deckId = deckLink.dataset.deckId;
                if (decks[deckId]) {
                    activeDeckId = deckId;
                    deckTitleStudy.textContent = decks[deckId].name;
                    restartSession();
                    showScreen('mainDeck');
                } else {
                    showWarningModal('This deck no longer exists.');
                }
            }
        }

        learningHistoryContainer.addEventListener('click', handleStudyLinkClicks);
        scheduleContainer.addEventListener('click', handleStudyLinkClicks);

        downloadHistoryBtn.addEventListener('click', () => {
            if(learningHistory.length === 0) return;
            const yamlString = jsyaml.dump(learningHistory); 
            const blob = new Blob([yamlString], { type: 'text/yaml' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob); 
            link.download = 'learning_history.yaml';
            link.click(); 
            URL.revokeObjectURL(link.href);
        });
        uploadHistoryBtn.addEventListener('click', () => historyUploadInput.click());
        historyUploadInput.addEventListener('change', (e) => {
            const file = e.target.files[0]; 
            if (!file) return; 
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const importedHistory = jsyaml.load(event.target.result);
                    if (Array.isArray(importedHistory)) {
                        const existingIds = new Set(learningHistory.map(r => r.id));
                        const newRecords = importedHistory.filter(r => r && r.id && !existingIds.has(r.id));
                        learningHistory.unshift(...newRecords);
                        learningHistory.sort((a,b) => new Date(b.timestamp) - new Date(a.timestamp));
                        saveLearningHistory(); 
                        renderLearningHistory(learningSearchInput.value);
                    }
                } catch (err) { 
                    console.error("Failed to parse history file", err); 
                    showWarningModal("Could not read the uploaded history file."); 
                }
            };
            reader.readAsText(file); 
            e.target.value = '';
        });

        // --- INITIALIZATION ---
        function isLocalStorageAvailable() { 
            try { 
                const x = '__storage_test__'; 
                window.localStorage.setItem(x, x); 
                window.localStorage.removeItem(x); 
                return true; 
            } catch (e) { 
                return false; 
            } 
        }
        function init() {
            if (!isLocalStorageAvailable()) document.getElementById('storage-warning').classList.remove('hidden');
            loadDecks(); 
            loadApiKey(); 
            loadLearningHistory();
            decksContainer.addEventListener('click', handleDeckListActions);
            showAnswerBtn.addEventListener('click', flipCard);
            ratingButtons.forEach(button => button.addEventListener('click', handleRating));
            restartBtn.addEventListener('click', restartSession);
            cardsListContainer.addEventListener('click', handleCardListClick);
            generateCardsBtn.addEventListener('click', handleGenerateCards);
            learningSearchInput.addEventListener('input', () => renderLearningHistory(learningSearchInput.value));
            goToSettingsLink.addEventListener('click', (e) => { e.preventDefault(); showScreen('settings'); });
            backToMainFromCompleteBtn.addEventListener('click', () => {
                showScreen('mainView'); 
                showTab('decks');
                setTimeout(() => {
                    const deckEl = decksContainer.querySelector(`[data-deck-id="${activeDeckId}"]`);
                    if (deckEl) deckEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }, 100); 
            });
            showTab('decks'); 
            showScreen('mainView');
        }
        init();
    });
    </script>
</body>
</html>

